---
---

## A note on software

The key R packages for this lesson are

- [sf](){:.rlib}
- [rgdal](){:.rlib}

In addition to the common case of depending on other R packages, these have dependencies on system libraries. System libraries cannot be installed by R's `install.packages()` and must be aquired separately. The good people at the [Open Source Geospatial Foundation](https://github.com/OSGeo) make it free and easy to add the critical system libraries:

- [GDAL](https://www.gdal.org) for read/write in geospatial data formats
- [GEOS](https://trac.osgeo.org/geos) for geometry operations
- [PROJ.4](http://proj4.org/) for cartographic projections

===

## Importing vector data

The [US Census website](http://www2.census.gov/geo/tiger/GENZ2014/shp/cb_2014_us_county_5m.zip) distributes county polygons (and much more) that are provided with the handouts. The [sf](){:.rlib} package reads shapefiles (".shp") and most other vector data:


~~~r
library(sf)
~~~

~~~
Error in library(sf): there is no package called 'sf'
~~~

~~~r
library(rgdal)
~~~

~~~
Error in library(rgdal): there is no package called 'rgdal'
~~~

~~~r
shp <- 'data/cb_2016_us_county_5m'
counties <- st_read(shp, stringsAsFactors = FALSE)
~~~

~~~
Error in st_read(shp, stringsAsFactors = FALSE): could not find function "st_read"
~~~
{:.text-document title="{{ site.handouts }}"}

===

The `counties` object is a `data.frame` that includes a `sfc`, which stands for "simple feature column". This special column is usually called "geometry" or "geom".


~~~r
head(counties)
~~~
{:.input}
~~~
Error in head(counties): object 'counties' not found
~~~
{:.output}

===

## Geometry types

Like any `data.frame` column, the `geometry` column is comprised of a single data type. The "MULTIPOLYGON" is just one of several standard geometric data types.

| Common Types | Description                                                                                                                  |
|--------------+------------------------------------------------------------------------------------------------------------------------------|
| POINT        | zero-dimensional geometry containing a single point                                                                          |
| LINESTRING   | sequence of points connected by straight, non-self intersecting line pieces; one-dimensional geometry                        |
| POLYGON      | sequence of points in closed, non-intersecting rings; the first denotes the exterior ring, any subsequent rings denote holes |
| MULTI*       | set of * (POINT, LINESTRING, or POLYGON)                                                                                     |

The spatial data types are built upon eachother in a logical way: lines are built from points, polygons are built from lines, and so on.
{:.notes}

===

## Coordinate Reference System (CRS)

A key feature of a **geo**spatial data type is its associated CRS, stored as both an EPSG ID and a PROJ.4 string.


~~~r
st_crs(counties)
~~~
{:.input}
~~~
Error in st_crs(counties): could not find function "st_crs"
~~~
{:.output}

===

## Bounding Box

A bounding box for all or any subset of records is generated by `st_bbox()`


~~~r
st_bbox(counties)
~~~
{:.input}
~~~
Error in st_bbox(counties): could not find function "st_bbox"
~~~
{:.output}


~~~r
library(dplyr)
counties_md <- filter(counties, STATEFP == '24')
~~~
{:.input}
~~~
Error in filter(counties, STATEFP == "24"): object 'counties' not found
~~~
{:.input}
~~~r
st_bbox(counties_md)
~~~
{:.input}
~~~
Error in st_bbox(counties_md): could not find function "st_bbox"
~~~
{:.output}

===

## Grid

A bounding box summarizes the limits, but is not itself a geometry (not a POINT or POLYGON), even though it has a CRS attribute.


~~~r
st_crs(st_bbox(counties_md))
~~~
{:.input}
~~~
Error in st_crs(st_bbox(counties_md)): could not find function "st_crs"
~~~
{:.output}

===

A rectangular grid made over a `sf` object is a geometry---by default, a POLYGON.


~~~r
grid_md <- st_make_grid(counties_md, n = 4)
~~~

~~~
Error in st_make_grid(counties_md, n = 4): could not find function "st_make_grid"
~~~
{:.text-document title="{{ site.handouts }}"}

~~~r
grid_md
~~~
{:.input}
~~~
Error in eval(expr, envir, enclos): object 'grid_md' not found
~~~
{:.output}

===

## Plot Layers

Spatial objects defined by [sf](){:.rlib} are compatible with the `plot` function. Setting the `plot` parameter `add = TRUE` allows an existing plot to serve as a layer underneath the new one, so long as the CRS lines up.


~~~r
plot(grid_md)
~~~

~~~
Error in plot(grid_md): object 'grid_md' not found
~~~

~~~r
plot(counties_md, add = TRUE)
~~~

~~~
Error in plot(counties_md, add = TRUE): object 'counties_md' not found
~~~
{:.text-document title="{{ site.handouts }}"}

===

Instead of reading a shapefile, we can build spatial objects from coordinates. Here's a `sfc` object with a single "POINT", corresponding to SESYNC's postition in WGS84 degrees lat, lon.


~~~r
sesync <- st_sfc(
    st_point(c(-76.503394, 38.976546)),
    crs = 4326)
~~~

~~~
Error in st_sfc(st_point(c(-76.503394, 38.976546)), crs = 4326): could not find function "st_sfc"
~~~
{:.text-document title="{{ site.handouts }}"}

===

The CRS for SESYNC is not identical to the CRS for `counties`, but they are imperceptably different at the scale shown. Note that `plot` won't prevent you from layering up geometries with different coordinate systems: you must safegaurd your own plots from this mistake.


~~~r
counties_md <- st_transform(counties_md, crs = st_crs(sesync))
~~~

~~~
Error in st_transform(counties_md, crs = st_crs(sesync)): could not find function "st_transform"
~~~

~~~r
plot(counties_md$geometry)
~~~

~~~
Error in plot(counties_md$geometry): object 'counties_md' not found
~~~

~~~r
plot(sesync, col = "green", pch = 20, add = TRUE)
~~~

~~~
Error in plot(sesync, col = "green", pch = 20, add = TRUE): object 'sesync' not found
~~~
{:.text-document title="{{ site.handouts }}"}

The arguments `col` and `pch` are graphical parameters used in base R, see `?par`.
{:.notes}

===

## Subsetting vector data

An object created with `st_read` is a `data.frame`, which is why the `dplyr` function `filter` used above on the **non**-geospatial column named "STATEFP" worked normally. The equivalent of a "filter" operation on the "geometry" column is called a spatial "overlay". It can be seen as a type of subsetting based on spatial (rather than numeric or string) matching. Matching is implemented with functions like `st_within(x, y)`


~~~r
st_within(sesync, counties_md)
~~~
{:.input}
~~~
Error in st_within(sesync, counties_md): could not find function "st_within"
~~~
{:.output}

The output implies that the 1st (and only) point in `sesync` is within the 5th element of `counties_md`.

===

Question
: What was the message issued by the last command all about?

Answer
: {:.fragment} It is a reminder that all geometric calculations are performed as if the coordinates (in this case longitutde and latitude) are Cartesian x,y coordinates.

===

The overlay functions in the [sf](){:.rlib} package follow the pattern `st_predicate(x, y)` and perform the test "x [is] predicate y". Some key examples are:

| st_intersects | boundary or interior of x intersects boundary or interior of y |
| st_within     | interior and boundary of x do not intersect exterior of y      |
| st_contains   | y is within x                                                  |
| st_overlaps   | interior of x intersects interior of y                         |
| st_equals     | x has the same interior and boundary as y                      |

===

## Exercise 1

Produce a map of Maryland counties with the county that contains SESYNC colored in red.

[View solution](#solution-1)
{:.notes}

===

## Coordinate transformations

For the next part of this lesson, we import a new polygon layer corresponding to the 1:250k map of US hydrological units (HUC) [downloaded](http://water.usgs.gov/GIS/dsdl/huc250k_shp.zip) from the United States Geological Survey.


~~~r
shp <- 'data/huc250k'
huc <- st_read(shp, stringsAsFactors = FALSE)
~~~

~~~
Error in st_read(shp, stringsAsFactors = FALSE): could not find function "st_read"
~~~
{:.text-document title="{{ site.handouts }}"}

===

Compare the coordinate reference systems of `counties` and `huc`, as given by their Proj4 strings.


~~~r
st_crs(counties_md)$proj4string
~~~
{:.input}
~~~
Error in st_crs(counties_md): could not find function "st_crs"
~~~
{:.output}


~~~r
st_crs(huc)$proj4string
~~~
{:.input}
~~~
Error in st_crs(huc): could not find function "st_crs"
~~~
{:.output}

The Census data uses unprojected (longitude, latitude) coordinates, but `huc` is in an Albers equal-area projection (indicated as "+proj=aea").

===

Other parameters differ between the two coordinate systems, such as the "datum", which indicates the standard by which the irregular surface of the Earth is approximated by an ellipsoid. The function `st_transform()` converts a `sfc` between coordinate reference systems, specified with the parameter `crs = x`. A numeric `x` must be a valid EPSG code; a character `x` is interpretted as a PROJ.4 string.

Here is a slightly different Albers equal-area projection:


~~~r
prj <- '+proj=aea +lat_1=29.5 +lat_2=45.5 +lat_0=23 +lon_0=-96 +x_0=0 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs'
~~~
{:.text-document title="{{ site.handouts }}"}

===

Use `st_transform()` to assign the two layers to a common projection string (`prj`). This is a lot of work: it has to re-calculate new coordinates for every polygon in the `sfc`.


~~~r
counties_md <- st_transform(counties_md, crs = prj)
~~~

~~~
Error in st_transform(counties_md, crs = prj): could not find function "st_transform"
~~~

~~~r
huc <- st_transform(huc, crs = prj)
~~~

~~~
Error in st_transform(huc, crs = prj): could not find function "st_transform"
~~~

~~~r
sesync <- st_transform(sesync, crs = prj)
~~~

~~~
Error in st_transform(sesync, crs = prj): could not find function "st_transform"
~~~

~~~r
plot(counties_md$geometry)
~~~

~~~
Error in plot(counties_md$geometry): object 'counties_md' not found
~~~

~~~r
plot(huc, border = 'blue', add = TRUE)
~~~

~~~
Error in plot(huc, border = "blue", add = TRUE): object 'huc' not found
~~~

~~~r
plot(sesync, col = 'green', pch = 20, add = TRUE)
~~~

~~~
Error in plot(sesync, col = "green", pch = 20, add = TRUE): object 'sesync' not found
~~~
{:.text-document title="{{ site.handouts }}"}

===

## Geometric operations on vector layers

The data for a map of waterhsed boundaries within the state of MD is all here; in the country-wide `huc` and in the state boundary "surrounding" all of `counties_md`. To get just the huc in a MD outline:

- remove the internal county boundaries within the state
- clip the hydrological areas to their intersection with the state

===

The first step is a spatial **union** operation: we want the resulting object to combine the area covered by all the multipolygons in `counties_md`. To perform a union of all sub-geometries in a single `sfc`, we use the `st_union()` function with a single argument.


~~~r
state_md <- st_union(counties_md)
~~~

~~~
Error in st_union(counties_md): could not find function "st_union"
~~~

~~~r
plot(state_md)
~~~

~~~
Error in plot(state_md): object 'state_md' not found
~~~
{:.text-document title="{{ site.handouts }}"}

The output, `state_md`, is a new `sfc` that is no longer a column of a data frame. Tabular data can't safely survive a spatial union and is discarded.

===

The second step is a spatial **intersection**, since we want to limit the polygons to areas covered by both `huc` and `state_md`. The `st_intersection()` function intersects its first argument with the second.


~~~
Error in plot(state_md): object 'state_md' not found
~~~

~~~r
huc_md <- st_intersection(huc, state_md)
~~~

~~~
Error in st_intersection(huc, state_md): could not find function "st_intersection"
~~~

~~~r
plot(huc_md, border = 'blue', col = NA, add = TRUE)
~~~

~~~
Error in plot(huc_md, border = "blue", col = NA, add = TRUE): object 'huc_md' not found
~~~
{:.text-document title="{{ site.handouts }}"}

The individual hydrological units are preserved but any part of them (or any whole polygon) lying outside the `state_md` polygon is cut from the output. The attribute data remains in the corresponding records of the `data.frame`, but (as warned) has not been updated. For example, the "AREA" attribute of any clipped HUC does not reflect the new polygon.

===

The GEOS library provides many functions dealing with distances and areas. Many of these are accessible through the [sf](){:.rlib} package, including:

- `st_buffer`: to create a buffer of specific width around a geometry
- `st_distance`: to calculate the shortest distance between geometries
- `st_area`: to calculate the area of polygons

Keep in mind that all these functions use **planar** geometry equations and thus become less precise over larger distances, where the Earth's curvature is noticeable. To calculate geodesic distances that account for that curvature, checkout the [geosphere](){:.rlib} package.

===

## Exercise 2

Use `st_buffer` to create a 5km buffer around the `state_md` border and plot it as a dotted line (`plot(..., lty = 'dotted')`) over the true state border. **Hint**: check the layer's units with `st_crs()` and express any distance in those units.

[View solution](#solution-2)
{:.notes}
