---
excerpt: Vector Data
---

## R Packages

The key R packages for this lesson are

- [sf](){:.rlib}
- [raster](){:.rlib}

===

### OSGeo Dependencies

Most R packages depend on other R packages. The [sf](){:.rlib} and  [raster](){:.rlib}
packages also depend on system libraries.

- [GDAL](https://www.gdal.org) for read/write in geospatial data formats
- [GEOS](https://trac.osgeo.org/geos) for geometry operations
- [PROJ.4](http://proj4.org/) for cartographic projections

System libraries cannot be installed by R's `install.packages()`, but can be
bundled with these packages and for private use by them. Either way, the
necessary libraries are maintained by the good people at the [Open Source
Geospatial Foundation](https://github.com/OSGeo) for free and easy distribution.
{:.notes}

===

### Vector Data

The [US Census
website](http://www2.census.gov/geo/tiger/GENZ2014/shp/cb_2014_us_county_5m.zip)
distributes county polygons (and much more) that are provided with the handouts.
The [sf](){:.rlib} package reads shapefiles (".shp") and most other vector data:



~~~r
library(sf)

shp <- 'data/cb_2016_us_county_5m'
counties <- st_read(
  shp,
  stringsAsFactors = FALSE)
~~~
{:title="{{ site.data.lesson.handouts[0] }}" .text-document}


===

The `counties` object is a `data.frame` that includes a `sfc`, which stands for
"simple feature column". This special column is usually called "geometry" or
"geom" (not to be confused with ggplot's `geom`s)!



~~~r
> head(counties)
~~~
{:title="Console" .input}


~~~
Simple feature collection with 6 features and 9 fields
geometry type:  MULTIPOLYGON
dimension:      XY
bbox:           xmin: -114.7556 ymin: 29.26116 xmax: -81.10192 ymax: 38.77443
CRS:            4269
  STATEFP COUNTYFP COUNTYNS       AFFGEOID GEOID      NAME LSAD       ALAND
1      04      015 00025445 0500000US04015 04015    Mohave   06 34475567011
2      12      035 00308547 0500000US12035 12035   Flagler   06  1257365642
3      20      129 00485135 0500000US20129 20129    Morton   06  1889993251
4      28      093 00695770 0500000US28093 28093  Marshall   06  1828989833
5      29      510 00767557 0500000US29510 29510 St. Louis   25   160458044
6      35      031 00929107 0500000US35031 35031  McKinley   06 14116799068
     AWATER                       geometry
1 387344307 MULTIPOLYGON (((-114.7556 3...
2 221047161 MULTIPOLYGON (((-81.52366 2...
3    507796 MULTIPOLYGON (((-102.042 37...
4   9195190 MULTIPOLYGON (((-89.72432 3...
5  10670040 MULTIPOLYGON (((-90.31821 3...
6  14078537 MULTIPOLYGON (((-109.0465 3...
~~~
{:.output}


===

### Geometry Types

Like any `data.frame` column, the `geometry` column is comprised of a single
data type. The "MULTIPOLYGON" is just one of several standard geometric data
types.

=== 

| Common Types | Description |
|--------------|-------------|
| POINT        | zero-dimensional geometry containing a single point |
| LINESTRING   | sequence of points connected by straight, non-self intersecting line pieces; one-dimensional geometry |
| POLYGON      | sequence of points in closed, non-intersecting rings; the first denotes the exterior ring, any subsequent rings denote holes |
| MULTI*       | set of * (POINT, LINESTRING, or POLYGON) |

The spatial data types are built upon each other in a logical way: lines are
built from points, polygons are built from lines, and so on.
{:.notes}

===

We can create any of these spatial objects from coordinates.
Here's an `sfc` object with a single "POINT", corresponding to SESYNC's position
in WGS84 degrees latitude and degrees longitude, with the same coordinate
reference system as the `counties` object.



~~~r
sesync <- st_sfc(st_point(
    c(-76.503394, 38.976546)),
    crs = st_crs(counties))
~~~
{:title="{{ site.data.lesson.handouts[0] }}" .text-document}


===

### Coordinate Reference Systems

A key feature of a **geo**spatial data type is its associated CRS, stored as an
EPSG ID and an equivalent PROJ.4 string. We can print the CRS of a spatial 
object with `st_crs()`.



~~~r
> st_crs(counties)
~~~
{:title="Console" .input}


~~~
Coordinate Reference System:
  User input: 4269 
  wkt:
GEOGCS["GCS_North_American_1983",
    DATUM["North_American_Datum_1983",
        SPHEROID["GRS_1980",6378137,298.257222101]],
    PRIMEM["Greenwich",0],
    UNIT["Degree",0.017453292519943295],
    AUTHORITY["EPSG","4269"]]
~~~
{:.output}


===

### Bounding Box

A bounding box for all features in an `sf` data frame is generated by `st_bbox()`.



~~~r
> st_bbox(counties)
~~~
{:title="Console" .input}


~~~
      xmin       ymin       xmax       ymax 
-179.14734  -14.55255  179.77847   71.35256 
~~~
{:.output}


===

The bounding box is not a static attribute---it is determined on-the-fly for the
entire table or any subset of features. In this example, we subset the United States
counties by state ID 24 (Maryland). 

Because the `counties` object is a kind of `data.frame`, we can use [dplyr](){:.rlib}
verbs such as `filter` on it, just as we would with a non-spatial data frame.
{:.notes}



~~~r
library(dplyr)
counties_md <- filter(
  counties,
  STATEFP == '24')
~~~
{:title="{{ site.data.lesson.handouts[0] }}" .text-document}




~~~r
> st_bbox(counties_md)
~~~
{:title="Console" .input}


~~~
     xmin      ymin      xmax      ymax 
-79.48765  37.91172 -75.04894  39.72312 
~~~
{:.output}


===

### Grid

A bounding box summarizes the limits, but is not itself a geometry (not a POINT
or POLYGON), even though it has a CRS attribute.



~~~r
> st_crs(st_bbox(counties_md))
~~~
{:title="Console" .input}


~~~
Coordinate Reference System:
  User input: 4269 
  wkt:
GEOGCS["GCS_North_American_1983",
    DATUM["North_American_Datum_1983",
        SPHEROID["GRS_1980",6378137,298.257222101]],
    PRIMEM["Greenwich",0],
    UNIT["Degree",0.017453292519943295],
    AUTHORITY["EPSG","4269"]]
~~~
{:.output}


===

We can use `st_make_grid()` to make a rectangular grid over a `sf` object.
The grid is a geometry---by default, a POLYGON.



~~~r
grid_md <- st_make_grid(counties_md,
                        n = 4)
~~~
{:title="{{ site.data.lesson.handouts[0] }}" .text-document}


~~~
although coordinates are longitude/latitude, st_relate_pattern assumes that they are planar
~~~
{:.output}


===

Question
: What was the message issued by the last command all about?

Answer
: {:.fragment} It is a reminder that all geometric calculations are performed as
if the coordinates (in this case longitude and latitude) are Cartesian x,y
coordinates. This is OK because we are working at a small scale where the Earth's
curvature can be ignored.

===



~~~r
> grid_md
~~~
{:title="Console" .input}


~~~
Geometry set for 13 features 
geometry type:  POLYGON
dimension:      XY
bbox:           xmin: -79.48765 ymin: 37.91172 xmax: -75.04894 ymax: 39.72312
CRS:            4269
First 5 geometries:
~~~
{:.output}


~~~
POLYGON ((-77.26829 37.91172, -76.15862 37.9117...
~~~
{:.output}


~~~
POLYGON ((-76.15862 37.91172, -75.04894 37.9117...
~~~
{:.output}


~~~
POLYGON ((-78.37797 38.36457, -77.26829 38.3645...
~~~
{:.output}


~~~
POLYGON ((-77.26829 38.36457, -76.15862 38.3645...
~~~
{:.output}


~~~
POLYGON ((-76.15862 38.36457, -75.04894 38.3645...
~~~
{:.output}


===

### Plot Layers

Spatial objects defined by [sf](){:.rlib} are compatible with the `plot`
function. Setting the `plot` parameter `add = TRUE` allows an existing plot to
serve as a layer underneath the new one. The two layers should have the same
coordinate reference system.

The following code plots the grid first, then the `ALAND` (land area) column of `counties_md`. 
This plots the county boundaries with the fill color of the polygons corresponding to the
area of the polygon.
The default color scheme means that larger counties appear yellow. Finally, we 
overlay the point location of SESYNC.
{:.notes}



~~~r
plot(grid_md)
plot(counties_md['ALAND'],
     add = TRUE)
plot(sesync, col = "green",
     pch = 20, add = TRUE)
~~~
{:title="{{ site.data.lesson.handouts[0] }}" .text-document}
![ ]({% include asset.html path="images/vector/unnamed-chunk-11-1.png" %})
{:.captioned}

But note that the `plot` function won't prevent you from layering up geometries
with different coordinate systems: you must safeguard your own plots from this
mistake. The arguments `col` and `pch`, by the way, are graphical parameters
used in base R, see `?par`.
{:.notes}

===

### Spatial Subsetting

An object created with `st_read` is a `data.frame`, which is why the `dplyr`
function `filter` used above on the **non**-geospatial column named "STATEFP"
worked normally. The equivalent of a filtering operation on the "geometry"
column is called a spatial "overlay".



~~~r
> st_within(sesync, counties_md)
~~~
{:title="Console" .input}


~~~
Sparse geometry binary predicate list of length 1, where the predicate was `within'
 1: 5
~~~
{:.output}


It can be seen as a type of subsetting based on spatial (rather than numeric or
string) matching. Matching is implemented with functions like `st_within(x, y)`.
The output implies that the 1<sup>st</sup> (and only) point in `sesync` is within the 5th
element of `counties_md`.
{:.notes}

===

The overlay functions in the [sf](){:.rlib} package follow the pattern
`st_predicate(x, y)` and perform the test "x [is] predicate y". Some key
examples are:

| st_intersects | boundary or interior of x intersects boundary or interior of y |
| st_within     | interior and boundary of x do not intersect exterior of y      |
| st_contains   | y is within x                                                  |
| st_overlaps   | interior of x intersects interior of y                         |
| st_equals     | x has the same interior and boundary as y                      |

===

### Coordinate Transforms

For the next part of this lesson, we import a new polygon layer corresponding to
the 1:250k [map of US hydrological units (HUC)](http://water.usgs.gov/GIS/dsdl/huc250k_shp.zip)
downloaded from the United States Geological Survey.



~~~r
shp <- 'data/huc250k'
huc <- st_read(
  shp,
  stringsAsFactors = FALSE)
~~~
{:title="{{ site.data.lesson.handouts[0] }}" .text-document}


===

Compare the coordinate reference systems of `counties` and `huc`, as given by
their PROJ.4 strings.



~~~r
> st_crs(counties_md)$proj4string
~~~
{:title="Console" .input}


~~~
[1] "+proj=longlat +datum=NAD83 +no_defs "
~~~
{:.output}




~~~r
> st_crs(huc)$proj4string
~~~
{:title="Console" .input}


~~~
[1] "+proj=aea +lat_1=29.5 +lat_2=45.5 +lat_0=23 +lon_0=-96 +x_0=0 +y_0=0 +datum=NAD27 +units=m +no_defs "
~~~
{:.output}


The Census data uses unprojected (longitude, latitude) coordinates, but `huc` is
in an Albers equal-area projection (indicated as `"+proj=aea"`).
{:.notes}

===

The function `st_transform()` converts an `sfc` between coordinate reference
systems, specified with the parameter `crs = x`. A numeric `x` must be a valid
EPSG code; a character `x` is interpreted as a PROJ.4 string.

For example, the following character string is a PROJ.4 string which has
a list of parameters that correspond to the [EPSG code 42303](https://epsg.io/42303), 
so you could get the same result by typing `prj <- 42303`.
{:.notes}



~~~r
prj <- '+proj=aea +lat_1=29.5 +lat_2=45.5 \
    +lat_0=23 +lon_0=-96 +x_0=0 +y_0=0    \
    +ellps=GRS80 +towgs84=0,0,0,0,0,0,0   \
    +units=m +no_defs'
~~~
{:title="{{ site.data.lesson.handouts[0] }}" .text-document}


PROJ.4 strings contain a reference to the type of projection---this one is another
Albers Equal Area---along with numeric parameters associated with that
projection. An additional important parameter that may differ between two
coordinate systems is the "datum", which indicates the standard by which the
irregular surface of the Earth is approximated by an ellipsoid in the
coordinates themselves.
{:.notes}

===

Use `st_transform()` to assign the two layers and SESYNC's location
to a common projection string (`prj`). 
This takes a few moments, as it recalculates coordinates for
every vertex in the `sfc`.



~~~r
counties_md <- st_transform(
  counties_md,
  crs = prj)
huc <- st_transform(
  huc,
  crs = prj)
sesync <- st_transform(
  sesync,
  crs = prj)
~~~
{:title="{{ site.data.lesson.handouts[0] }}" .text-document}


===



~~~r
plot(counties_md$geometry)
plot(huc$geometry,
     border = 'blue', add = TRUE)
plot(sesync, col = 'green',
     pch = 20, add = TRUE)
~~~
{:title="{{ site.data.lesson.handouts[0] }}" .text-document}
![ ]({% include asset.html path="images/vector/unnamed-chunk-18-1.png" %})
{:.captioned}

===

### Geometric Operations

The data for a map of watershed boundaries within the state of MD is all here:
in the country-wide `huc` and in the state boundary "surrounding" all of
`counties_md`. To get just the HUCs inside Maryland's borders:

- remove the internal county boundaries within the state
- clip the hydrological areas to their intersection with the state

===

The first step is a spatial **union** operation: we want the resulting object to
combine the area covered by all the multipolygons in `counties_md`.



~~~r
state_md <- st_union(counties_md)
plot(state_md)
~~~
{:title="{{ site.data.lesson.handouts[0] }}" .text-document}
![ ]({% include asset.html path="images/vector/unnamed-chunk-19-1.png" %})
{:.captioned}

To perform a union of all sub-geometries in a single `sfc`, we use the
`st_union()` function with a single argument. The output, `state_md`, is a new
`sfc` that is no longer a column of a data frame. Tabular data can't safely
survive a spatial union because the polygons corresponding to the attributes
in the table have been combined into a single larger polygon. So the data frame
columns are discarded.
{:.notes}

===

The second step is a spatial **intersection**, since we want to limit the
polygons to areas covered by both `huc` and `state_md`.



~~~r
huc_md <- st_intersection(
  huc,
  state_md)
~~~
{:title="{{ site.data.lesson.handouts[0] }}" .text-document}


~~~
Warning: attribute variables are assumed to be spatially constant throughout all
geometries
~~~
{:.output}


===



~~~r
plot(state_md)
plot(huc_md, border = 'blue',
     col = NA, add = TRUE)
~~~
{:title="{{ site.data.lesson.handouts[0] }}" .text-document}
![ ]({% include asset.html path="images/vector/unnamed-chunk-21-1.png" %})
{:.captioned}

The `st_intersection()` function intersects its first argument with the second.
The individual hydrological units are preserved but any part of them (or any
whole polygon) lying outside the `state_md` polygon is cut from the output. The
attribute data remains in the corresponding records of the `data.frame`, but (as
warned) has not been updated. For example, the "AREA" attribute of any clipped
HUC does not reflect the new polygon.
{:.notes}

===

The GEOS library provides many functions dealing with distances and areas. Many
of these are accessible through the [sf](){:.rlib} package, including:

- `st_buffer`: to create a buffer of specific width around a geometry
- `st_distance`: to calculate the shortest distance between geometries
- `st_area`: to calculate the area of polygons

Keep in mind that all these functions use **planar** geometry equations and thus
become less precise over larger distances, where the Earth's curvature is
noticeable. To calculate geodesic distances that account for that curvature,
check out the [geosphere](){:.rlib} package.
{:.notes}
