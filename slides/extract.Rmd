---
excerpt: Mixing Data Types
---

## Crossing Rasters with Vectors

EDIT THIS OBSOLETE COUPLE OF PARAGRAPHS

Raster and vector geospatial data in R require different packages. 
The creation of geospatial tools in R has been a community effort, and not
necessarily a well-organized one. Development is still ongoing on many packages
dealing with raster and vector data.
One current stumbling block is that the [raster](){:.rlib} package, which is tightly 
integrated with the older [sp](){:.rlib} package, has not fully caught up to the [sf](){:.rlib} package. 
The [stars](https://r-spatial.github.io/stars/) package aims to remedy this problem,
and others, but has not yet released a "version 1.0" (it's at 0.5 as of this
writing). In addition, the [terra](){:.rlib} package, which is better integrated with
[sf](){:.rlib}, may ultimately replace the [raster](){:.rlib} package. It is also still in
development (version 0.6 as of this writing).
{:.notes}

Although not needed in this lesson, you may notice in some cases that it is necessary to
convert a vector object from [sf](){:.rlib} (class beginning with `sfc*`) to [sp](){:.rlib}
(class beginning with `Spatial*`) for the vector object to interact with rasters.
You can do this by calling `sp_object <- as(sf_object, 'Spatial')`.
{:.notes}

The `st_extract()` function allows subsetting and aggregation of raster values based
on a vector spatial object. For example we might want to extract the NLCD land cover 
class at SESYNC's location.

```{r, fig.keep='last', handout = 0}
plot(nlcd)
plot(sesync, col = 'green',
     pch = 16, cex = 2, add = TRUE)
```

===

Call `st_extract()` on the `nlcd` raster and the `sfc` object containing SESYNC's point location.
When extracting by point locations, the result is another `sfc` with `POINT` geometry and
a column containing the pixel values from the raster at each point.

```{r, handout = 0}
sesync_lc <- st_extract(nlcd, sesync)
```

```{r}
sesync_lc
```

===

Instead of returning a point geometry, you might want to mask a raster by a point geometry instead. 
You can use the indexing operator `[]` to do this. This will set
all pixels in the raster not overlapping the point geometry to `NA`.

```{r}
nlcd[sesync]
```

===

To extract with a polygon, first subset the raster by the polygon geometry. For example
here we subset the low-resolution NLCD raster by the first row of `counties_md` 
(Baltimore City), resulting in a raster with smaller dimensions that we can plot.

```{r, handout = 0}
baltimore <- nlcd_agg[counties_md[1, ]]
plot(baltimore)
```

The expression `nlcd_agg[counties_md[1, ]]` is equivalent to `st_crop(nlcd_agg, counties_md[1, ])`.
The version with `st_crop()` is a bit easier to use with pipes.

===

Here we use a pipe to crop the high-resolution NLCD raster to the boundaries of Baltimore City,
pull the values as a matrix, and tabulate them.

```{r, handout = 0}
nlcd %>%
  st_crop(counties_md[1, ]) %>%
  pull %>%
  table
```

===

To get a summary of raster values for **each** polygon in an `sfc`
object, use `aggregate()` and choose an aggregation function with the `FUN` argument. For
example, this gives the most common land cover type for each polygon in
`huc_md`.

```{r, handout = 0, warning = FALSE}
mymode <- function(x) names(which.max(table(x)))

modal_lc <- aggregate(nlcd_agg, huc_md, FUN = mymode) 
```

The [stars](){:.rlib} package (and base R for that matter) currently have no built-in mode function
so we define a simple one here and pass it to `aggregate()`.
{:.notes}

===

The result is a `stars` object but we can convert it to an `sfc` object containing polygon
geometry.

```{r}
st_as_sf(modal_lc))
```

Alternatively, we can extract the values from the `stars` object, add them as a new
column to `huc_md`, and plot:

```{r, handout = 0}
huc_md <- huc_md %>% 
  mutate(modal_lc = modal_lc[[1]])

plot(huc_md['modal_lc'])
```
